---
title: "Fourier_Fall_Feats"
author: "James A. Coppock"
date: "10/15/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

##Load in Data

```{r}
#setwd("~/Desktop/Duke/Class/Fall 2020/Biomedical DS/BME590_Fall_Detection")
#install.packages("Rcpproll")
#install.packages("slider")
library(RcppRoll)
library(slider)
library(tibble)
library(purrr)
library(lubridate, warn.conflicts = FALSE)
library(dplyr, warn.conflicts = FALSE)
library(readxl)
library(evobiR)
library(patchwork)
library(gridExtra)
library(moments)
library(corrplot)
library(psych)
library(corrr)
library(signal)
library(swdft)
library(seewave)
library(fftw)
Falls_df1 <- read.csv('Fall_Data1.csv')
Falls_df2 <- read.csv('Fall_Data2.csv')
Data  <- rbind(Falls_df1,Falls_df2)
Data_EDA <- rbind(Falls_df1,Falls_df2)
rm(Falls_df1)
rm(Falls_df2)
```

## Including Plots


```{r}
cat('The Number of Falls in this Set of Data is:',(sum(Data$Target)),'\n')
Fs <- 100
win <- 2
stp <- 0.5
window <-win*Fs
step <- stp*Fs

Falls_df <- subset(Data, Target==1)
noFalls_df<- subset(Data, Target==0)

```

Perform Fourier Transform on Initial Dataframe and Plot Results

```{r}

plot.frequency.spectrum <- function(X.k, title,xlimits=c(0,length(X.k))) {
  plot.data  <- cbind(0:(length(X.k)-1), Mod(X.k))
  plot.data[2:length(X.k),2] <- 2*plot.data[2:length(X.k),2] 
  plot(plot.data, t="h", lwd=2, main=title, 
       xlab="Frequency (Hz)", ylab="Strength",
       xlim=xlimits, ylim=c(0,max(Mod(plot.data[,2]))))
}

par(mfrow=c(3,3))
plot.frequency.spectrum(fft(Data_EDA$accX), "Acceleration X",xlimits=c(0,50))
plot.frequency.spectrum(fft(Data_EDA$accY), "Acceleration Y",xlimits=c(0,50))
plot.frequency.spectrum(fft(Data_EDA$accZ), "Acceleration Z",xlimits=c(0,50))

plot.frequency.spectrum(fft(Data_EDA$angX), "Angular Rotation X",xlimits=c(0,50))
plot.frequency.spectrum(fft(Data_EDA$angY), "Angular Rotation Y",xlimits=c(0,50))
plot.frequency.spectrum(fft(Data_EDA$angZ), "Angular Rotation Z",xlimits=c(0,50))

plot.frequency.spectrum(fft(Data_EDA$maxX), "Magnetic Flux Density X",xlimits=c(0,50))
plot.frequency.spectrum(fft(Data_EDA$magY), "Magnetic Flux Density Y",xlimits=c(0,50))
plot.frequency.spectrum(fft(Data_EDA$magZ), "Magnetic Flux Density Z",xlimits=c(0,50))

```

```{r}
set.seed(97)
## 80% of the sample size
smp_size <- floor(0.80 * nrow(Falls_df))
falls_train_ind <- sample(seq_len(nrow(Falls_df)), size = smp_size)

Falls_train <- Falls_df[falls_train_ind, ]
Falls_test <- Falls_df[-falls_train_ind, ]


smp_size <- floor(0.80 * nrow(noFalls_df))
nofalls_train_ind <- sample(seq_len(nrow(noFalls_df)), size = smp_size)

noFalls_train <- Falls_df[nofalls_train_ind, ]
noFalls_test <- Falls_df[-nofalls_train_ind, ]

Train_df <- rbind(noFalls_train,Falls_train)
Test_df <- rbind(noFalls_test,Falls_test)
```

TRAIN BUTTERWORTH
```{r}
bf <- signal::butter(4, 1/49, type="low")
Time <- Train_df$Time
accX <- signal::filtfilt(bf, Train_df$accX)
accY <- signal::filtfilt(bf, Train_df$accY)
accZ <- signal::filtfilt(bf, Train_df$accZ)
  
angX <- signal::filtfilt(bf, Train_df$angX)
angY <- signal::filtfilt(bf, Train_df$angY)
angZ <- signal::filtfilt(bf, Train_df$angZ)
  
maxX <- signal::filtfilt(bf, Train_df$maxX)
magY <- signal::filtfilt(bf, Train_df$magY)
magZ <- signal::filtfilt(bf, Train_df$magZ)

Target <- Train_df$Target

Train_df <- data.frame(Time, accX, accY, accZ, angX, angY, angZ, maxX, magY, magZ, Target)
str(Train_df)
```

TEST BUTTERWORTH
```{r}
Time <- Test_df$Time
accX <- signal::filtfilt(bf, Test_df$accX)
accY <- signal::filtfilt(bf, Test_df$accY)
accZ <- signal::filtfilt(bf, Test_df$accZ)
  
angX <- signal::filtfilt(bf, Test_df$angX)
angY <- signal::filtfilt(bf, Test_df$angY)
angZ <- signal::filtfilt(bf, Test_df$angZ)
  
maxX <- signal::filtfilt(bf, Test_df$maxX)
magY <- signal::filtfilt(bf, Test_df$magY)
magZ <- signal::filtfilt(bf, Test_df$magZ)

Target <- Test_df$Target

Test_df <- data.frame(Time, accX, accY, accZ, angX, angY, angZ, maxX, magY, magZ, Target)
```

Define SWDFT

```{r}

N_train <- length(Train_df)
window_size <- 32

```

Try using SWDFT

```{r}

# https://cran.r-project.org/web/packages/swdft/vignettes/swdft-intro.html (useful)
swdft_fft <- function(x, n, taper=1) {
  N <- length(x)
  P <- N - n + 1
  a <- array(data = NA, dim = c(n, P))

  for (p in n:N) {
    a[, p - n + 1] <- Mod(stats::fft(z = x[(p - n + 1):p] * taper))^2
  }

  return(a)
}

entropy <- function(a){
  sh(Mod(fft(a)), alpha = "shannon")
}

mean_energy <- function(a){
  # J/Hz; source: http://aaronscher.com/Course_materials/Communication_Systems/documents/Energy_signals_matlab_tutorial.pdf
  mean(Mod(fft(a))^2)
}

total_energy <- function(a){
  # I think you are missing a ^2 here
  sum(Mod(fft(a)))
}

power <- function(a){
  # I think this might be the same thing as mean energy 
  mean(Mod(fft(a))^2)
}

sum_coefficients <- function(a){
  # what are coefficients here? idk how this is different than total energy
  sum(Mod(fft(a)))
}

entropy_accX <- SlidingWindow("entropy", abs(Train_df$accX), window, step)
meanEnergy_accX <- SlidingWindow("mean_energy", abs(Train_df$accX), window, step)
totalEnergy_accX <- SlidingWindow("total_energy", abs(Train_df$accX), window, step)
power_accX <- SlidingWindow("power", abs(Train_df$accX), window, step)
sum_coefficients_accX <- SlidingWindow("sum_coefficients", abs(Train_df$accX), window, step)

entropy_angX <- SlidingWindow("entropy", abs(Train_df$angX), window, step)
meanEnergy_angX <- SlidingWindow("mean_energy", abs(Train_df$angX), window, step)
totalEnergy_angX <- SlidingWindow("total_energy", abs(Train_df$angX), window, step)
power_angX <- SlidingWindow("power", abs(Train_df$angX), window, step)
sum_coefficients_angX <- SlidingWindow("sum_coefficients", abs(Train_df$angX), window, step)

entropy_magX <- SlidingWindow("entropy", abs(Train_df$maxX), window, step)
meanEnergy_magX <- SlidingWindow("mean_energy", abs(Train_df$maxX), window, step)
totalEnergy_magX <- SlidingWindow("total_energy", abs(Train_df$maxX), window, step)
power_magX <- SlidingWindow("power", abs(Train_df$maxX), window, step)
sum_coefficients_magX <- SlidingWindow("sum_coefficients", abs(Train_df$maxX), window, step)

Targets <- SlidingWindow("max", Train_df$Target, window, step)


# Efficient way to perform calculations on all variables and store in new dataframe? Old way I did it in EDA.RMD could work, but it's very inefficient. 

# only doing x?

```

Check if new features correlate with target

```{r, fig.width=10, fig.height=10}

fft_df <- data.frame(entropy_accX, entropy_angX, entropy_magX,
                     meanEnergy_accX, meanEnergy_angX, meanEnergy_magX,
                     totalEnergy_accX, totalEnergy_angX, totalEnergy_magX,
                     Targets)

pairs(fft_df)

```
```{r}

```


```{r}
apply(df,2,function(x) fft(as.numeric(x)))
bf <- signal::butter(4, 1/49, type="low")
accX <- signal::filtfilt(bf, Train_df$accX)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
